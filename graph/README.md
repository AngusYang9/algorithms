# 图

- `B` [深度优先搜索](/graph/depth-first-search.html)（DFS）
- `B` [广度优先搜索](/graph/breadth-first-search.html)（BFS）
- `B` [克鲁斯克尔演算法](/graph/kruskal.html) - 寻找加权无向图的最小生成树 (MST)
- `A` [戴克斯特拉算法](/graph/dijkstra.html) - 找到图中所有顶点的最短路径
- `A` [贝尔曼-福特算法](/graph/bellman-ford.html) - 找到图中所有顶点的最短路径
- `A` [弗洛伊德算法](/graph/floyd-warshall.html) - 找到所有 `顶点对` 之间的最短路径
- `A` [判圈算法](/graph/detect-cycle.html) - 对于有向图和无向图 (基于 DFS 和不相交集的版本)
- `A` [普林演算法](/graph/prim.html) - 寻找加权无向图的最小生成树 (MST)
- `A` [拓扑排序](/graph/topological-sorting.html) - DFS 方法
- `A` [关节点](/graph/articulation-points.html) - Tarjan 算法 (基于 DFS)
- `A` [桥](/graph/bridges.html) - 基于 DFS 的算法
- `A` [欧拉回径与一笔画问题](/graph/eulerian-path.html) - Fleury 的算法 - 一次访问每个边
- `A` [哈密顿图](/graph/hamiltonian-cycle.html) - 恰好访问每个顶点一次
- `A` [强连通分量](/graph/strongly-connected-components.html) - Kosaraju 算法
- `A` [旅行推销员问题](/graph/travelling-salesman.html) - 尽可能以最短的路线访问每个城市并返回原始城市
